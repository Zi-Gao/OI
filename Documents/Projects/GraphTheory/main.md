# 图论之最短路径

## 0000.什么是图

### 00.图的简介

**图论 (Graph theory)** 是数学的一个分支，图是图论的主要研究对象。**图 (Graph)** 是由若干给定的顶点及连接两顶点的边所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。

在OI中，图的顶点只是抽象的一个点，连接两个点的“线”。一个图大概长这样：

### 01.图的概念

1.  **顶点**：就是下**图中的圆圈**。上面的数字就是他的编号，用来描述不同的点。

2.  **边**：下图中**连接两个圆圈的线**就是边了。

3.  **边权**：下图中边上面的数字就是边权。大概可以理解为**边的长度**，也就是两个点的距离。但实际上边**权是可以为负数**的，所以不能完全理解为边的长度。

以上是介绍图的基本组成部分。图还分种类，我只介绍简单的两种\~\~，因为其他的我不会\~\~。

1.  **无向图**：顾名思义，就是没有方向。具体来说就是 **A点到B点有边，那么B点到A点就有边，A点到B点的边权=B点到A点的边权**。

2.  **有向图**：与无向图相对，**A点到B点有边，但B点到A点不一定有边，A点到B点的边权不一定等于B点到A点的边权**。

## 0010.图的储存

我们已经了解了什么是图，但要离实现有关图的程序还要解决一个问题：**数据结构**。

我们再来观察一下这个图，里面有两个东西：点和边权。那么我们可以用一个数组储`e`来存储，其中`e[i][j]`表示**i点到j点的边权**。不连接的点用正无穷表示，至于为啥是因为方便算法设计，i=j时储存为0。

这个图存下来大概是这样：

## 0010.图的遍历

之前大家学习过**深度优先搜索(Depth First Search)**，也许也有人听说过**宽度优先搜索(Breadth First Search)**。其中的“深度”和“宽度”，其实就是指在图的遍历中的访问顺序。

### 00.DFS

**深度优先搜索**顾名思义就是先遍历深度。具体说就是**一直往下走，走到底，再往上退后一层，继续往下走，直到把每一个点都遍历了****。

模板代码:

```c++
/*
 *cur: 当前的点
 *cnt:遍历的点个数
 *INF:正无穷
 *e:邻接矩阵
 *dfs_book:标记数组
 */
void dfs(int cur){
	printf("%d ",cur);
	++cnt;
	if(cnt==n) return;
	for(int i=1;i<=n;i++){
		if(e[cur][i]<INF&&dfs_book[i]==0){
			dfs_book[i]=1;
			dfs(i);
		}
	}
}
```

### 01.BFS

**宽度优先搜索**顾名思义就是先遍历宽度。具体就是**从一个出发，把与之相邻的每一点遍历之后，又以与之相邻的第一个点为出发点，遍历与之相邻的没遍历过的点**。

具体实现起来我们可以使用一个**队列**，是一个**先进先出(FIFO—first in first out)**的数据结构，与**栈**的数据结构相对。**我们从一个起始的顶点开始，将与之相邻的所以点入队，之后出队一个元素，这个元素就是当前所在的点。又继续将此时队列顶端的点所相邻的点入**队……重复操作，就实现了宽搜。

模板代码:

```c++
/*
 *cur: 当前的点
 *bfs_book:标记数组
 *INF:正无穷
 *e:邻接矩阵
 *que:队列
 *head:队头
 *tail:队尾
 */
void bfs(){
	bool bfs_book[MAX_SIZE]={0};
	int que[MAX_SIZE]={0},head=0,tail=0,cur=1;

	que[tail++]=cur;
	bfs_book[cur]=1;

	while(head<tail && tail<n){
		cur=que[head];
		for(int i=1;i<=n;i++){
			if(e[cur][i]!=INF && !bfs_book[i]){
				que[tail++]=i;
				bfs_book[i]=1;
			}
			if(tail==n) break;
		}
		head++;
	}

	for(int i=1;i<=n;i++){
		if(bfs_book[i]) printf("%d ",i);
	}
}
```

## 0011.最短路径

### 00.Floyd-Warshall

### 10.Dijkstra
